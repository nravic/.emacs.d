import os
import numpy as np
import pandas as pd
from numpy import linalg as la


# grab amcl data for every chuck at the site and process
def data_pipeline(filename):
    df = pd.read_csv(filename, error_bad_lines=False, low_memory=False)
    df['timestamp'] = df['timestamp'].astype('datetime64[s]')
    df.sort_values(by='timestamp', inplace=True)
    df.reset_index(inplace=True)

    return df


# find max eigenvalues for each chuck over time_window period
def get_max_eigenvalues(df):
    evalue_dict = {}
    timestamp_dict = {}
    posex_dict = {}
    posey_dict = {}
    chucks = df.id.unique().tolist()

    for c in range(len(chucks) - 1):
        df_c = df[df['id'] == chucks[c]]
        df_c.sort_values(by='timestamp', inplace=True)
        df_c.reset_index(inplace=True)
        timestamps = df_c['timestamp']
        posex = df_c['x']
        posey = df_c['y']

        max_evalue = []

        for t in range(len(timestamps)):
            try:
                cov = np.array(
                    [[df_c['setCov_xx'][t], df_c['setCov_xy'][t], 0],
                     [df_c['setCov_xy'][t], df_c['setCov_yy'][t], 0],
                     [0, 0, df_c['setCov_tt'][t]]])
            except KeyError:
                print('KeyError at key {}'.format(t))
                break

            # get eigenvalues
            w, v = la.eig(cov)
            max_evalue.append(max(w))

        evalue_dict[chucks[c]] = max_evalue
        timestamp_dict[chucks[c]] = timestamps
        posex_dict[chucks[c]] = posex
        posey_dict[chucks[c]] = posey

    return evalue_dict, timestamp_dict, posex_dict, posey_dict


def jump_overlay(jumpfile, chuck_name):
    df_jump = pd.read_csv(jumpfile, error_bad_lines=False, low_memory=False)
    df_jump['timestamp'] = df_jump['timestamp'].astype('datetime64[s]')
    df_jump.sort_values(by='timestamp', inplace=True)
    df_jump.reset_index(inplace=True)

    df_c = df_jump[df_jump['id'] == chuck_name]
    df_c.sort_values(by='timestamp', inplace=True)
    df_c.reset_index(inplace=True)
    timestamps = df_c['timestamp']

    jump_vals_t = timestamps

    return jump_vals_t


# ## Main ##

# chuck_name = 'rosie-cnb'
# filename = 'data/cnbnap.csv'
# jumpfile = 'data/cnbnap_jump.csv'
# df = data_pipeline(filename)

# evalue_dict, timestamp_dict, _, _ = get_max_eigenvalues(df)
# jump_vals_t = jump_overlay(jumpfile, chuck_name)

# min_threshold = 5*60

# timestamps = timestamp_dict[chuck_name]
# jump_points = []
# jump_timestamps = []
# chuck_evalue = evalue_dict[chuck_name]
# # intersection of jump and max eigenvalues
# for i in range(len(timestamps)-1):
#     if len(jump_vals_t) == 0:
#         pass
#     else:
#         for k in range(len(jump_vals_t)):
#             if abs((timestamps[i].value//10**9) - (jump_vals_t[k].value//10**9)) < min_threshold:
#                 jump_points.append(chuck_evalue[i])
#                 jump_timestamps.append(timestamps[i])
#             else:
#                 pass

# # with the max evalues at every timestep for each chuck, run simple analysis
# stds = []
# means = []
# # get mean and std for entire SITE
# for key in evalue_dict:
#     # remove maxes
#     maxes_out = np.delete(evalue_dict[key], np.where(evalue_dict[key] == max(evalue_dict[key])))
#     stds.append(np.std(np.trim_zeros(maxes_out)))
#     means.append(np.mean(np.trim_zeros(maxes_out)))

# # test 'detection' and remove max means and stds
# std = np.mean(np.delete(stds, np.where(stds == max(stds))))
# mean = np.mean(np.delete(means, np.where(means == max(means))))

# # plots
# chuck_eigs = chuck_evalue
# chuck_timestamp = timestamp_dict[chuck_name]
# sd1 = (mean+std) * np.ones(len(chuck_eigs))
# sd2 = (mean+(2*std)) * np.ones(len(chuck_eigs))
# sd3 = (mean+(3*std)) * np.ones(len(chuck_eigs))

# # getting 3 standard deviations
# plt.plot(chuck_timestamp, chuck_eigs)
# plt.plot(chuck_timestamp, sd1)
# plt.plot(chuck_timestamp, sd2)
# plt.plot(chuck_timestamp, sd3)

# # plot jump line segment
# plt.plot(jump_timestamps, jump_points, color='black', linewidth=3)
# plt.title(chuck_name)
# plt.ylabel('Max eigenvalues')
# plt.xlabel('Time')

# plt.show()
